<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>final_project_data_cleaning</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="final_project_data_cleaning_files/libs/clipboard/clipboard.min.js"></script>
<script src="final_project_data_cleaning_files/libs/quarto-html/quarto.js"></script>
<script src="final_project_data_cleaning_files/libs/quarto-html/popper.min.js"></script>
<script src="final_project_data_cleaning_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="final_project_data_cleaning_files/libs/quarto-html/anchor.min.js"></script>
<link href="final_project_data_cleaning_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="final_project_data_cleaning_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="final_project_data_cleaning_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="final_project_data_cleaning_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="final_project_data_cleaning_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


<link rel="stylesheet" href="body {
  margin: 0.5in; /* Set 0.5-inch margins */
}
@page {
  margin: 0.5in; /* Ensure 0.5-inch margins for print */
}">
</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<p><strong>City of Dallas Housing Affordability and Gentrification</strong> <strong>Brenda Castañeda (brendac29)</strong></p>
<p><strong>Background and Research Question</strong><br>
Housing affordability and gentrification in Dallas are important issues in Dallas, especially amid rapid population increase in the last decade. Gentrification is not a straightforward measure but rather a process that happens over time in a given area. Some factors that characterize gentrification are increases in property value (rising housing costs), neighborhood demographic shifts, reduction in the housing supply, and new investment in historically marginalized areas. In this project, I focus on rising housing costs and neighborhood demographic shifts. In particular, as rising home values and rental rates outpace income growth, this project seeks to explore the trend over time of home values, rents, and median household income, how these trends vary across racial groups, and what demographic shifts are evident across the city and how these might relate to gentrification. The overall policy question is whether Dallas residents are vulnerable to displacement in the face of rising housing costs and shifting demographic patterns.</p>
<p><strong>Data and Coding Approach</strong> First, I explored the relationship between the median household income and home values for each census tract in 2010 and 2020. I used median household income data from the ACS 2010-2020 dataset and Zillow’s Home Value Index which is a measure of the typical home value across a given region, to create a scatter plot where each point represents a census tract in the city of Dallas (Figure 1). Then, I explored this relationship across Racial categories. I created scatter plots of home values vs median household income of Black, Hispanic, Asian and non-Hispanic White households, respectively (Figure 2). After exploring this relationship, I shifted to explore trends in the rental housing. I used ACS Median household income data as well as Zillow’s Observed Rent Index (ZORI). Using ZORI, I found the mean rents over time from 2015-2023. Then, I estimated renter affordability by calculating 30% of median household income and dividing by 12 months. This number was a measure of the monthly rent that the median household in Dallas could afford. I calculated affordability for the median household as well as by race.<br>
After looking at home value and rental trends, I wanted to explore the demographic changes that occurred across the city. To do so, I estimated the percentage of the population that fit into the top racial categories (Black, Hispanic, non-Hispanic White, and Asian) in each census tract. Then, using a function, found the racial majority in each census tract. I merged the data with census tract shapefiles to create choropleths of the racial majority distribution across the city in 2010 and 2020 (Figure 4). One challenge I faced at this step was that I initially used 2020 census tract shapefiles but had a lot of missing data in the 2010 map. Since census tracts change every decade, I had to use different shapefiles for 2010 and 2020 which is why the tracts look slightly different for each year.<br>
I also wanted to look at changes in median household income and home value across the city between 2010 and 2020, so I used the data described above to plot the distribution of these variables across the city for 2010 and 2020. The first version of these maps had a continuous home value and median household income, respectively. However, it was difficult to compare given that all values in 2020 were generally higher than 2010. Therefore, I binned the data so that each category corresponded to a quartile in the distribution of the variable for each year.</p>
<p><strong>Findings</strong> The figure below shows a general positive relationship between home value and median household income. However, the data points for 2020 cluster higher on house value (y-axis), indicating an increase in home values compared to 2010. This suggests that house values have risen over time. The key takeaway from this initial correlation is that home values have increased between 2010 and 2020 and appear to have outpaced income growth. This upward shift in home values might point to challenges in housing affordability, especially for lower-income areas.<br>
<img src="Pictures\zhvi_mhi_all.png" class="img-fluid" alt="Median Household Income vs House Value"></p>
<p>The figure below shows the relationship between home value and median household income by race. Black households appear to have lower median household incomes and home values compared to other groups. Hispanic households have slightly higher values than Black households but still cluster at the lower end of the home value and median household income distribution. Non-Hispanic White and Asian households have greater spread and generally higher income and home values. It is evident that there are disparities between racial groups in terms of median household income and house values. These disparities may have been exacerbated by the rising home prices between 2010 and 2020. <img src="Pictures\zhvi_mhi_race.png" class="img-fluid" alt="Median Household Income vs House Value by Race)"></p>
<p>The next figure depicts mean rent over time as well as the rent that the median renter can afford by race. The median renter has an affordability gap that is consistent across time. However, when we subset by race, Hispanic and Black median renters have lower affordability rates than the median renter. It is particularly worth noting that the affordability gap for Black households is increasing over time. In 2015 the difference between the Black median renter affordability and the mean rent was $364 /month while in 2023 it was $489 /month. The gap in affordability for non-Hispanic White an Asian households is positive, meaning they can afford higher rents than the mean rent in the city. This plot is in the shiny app and allows for an easier comparison between selected racical groups.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Pictures\rent_affordability.png" class="img-fluid figure-img"></p>
<figcaption>Dallas Rent Affordability by Race</figcaption>
</figure>
</div>
<p>The figure below shows six maps illustrating trends in racial composition, income, and house values by census tract in Dallas between 2010 and 2020. The racial majority composition map shows largely segregated city with Hispanic and Black communities concentrated in the south and west sides of Dallas. Their distribution did not shift much from 2010 to 2020. Non-Hispanic White households predominate in northern Dallas. Some census tracts with Black or Hispanic racial majorities in 2010 shifted White majority in 2020.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Pictures\maps.png" class="img-fluid figure-img"></p>
<figcaption>Demographic and Home Value Shifts 2010 to 2020</figcaption>
</figure>
</div>
<p>The median household income maps show a concentration of low-income tracts in southern and western Dallas and higher income tracts in north Dallas. Furthermore, it is worth noting that the areas that experienced a racial majority shift from Black or Hispanic in 2010 to White in 2020 align closely with the areas that shifted from lower income in 2010 to higher income in 2020. Finally, low-value housing overlaps significantly with low-income areas concentrated in the south and west of the of city. Areas with low house values in 2010 align well with the areas that saw racial and income shifts from 2010 to 2020. This suggests the moving in of high-income households into areas with low home values.</p>
<p><strong>Policy Implications</strong> Black and Hispanic households are disproportionately affected by rising housing costs. Targeted affordable housing and rental assistance programs for low-SES minority groups are essential for addressing these disparities. Furthermore, the changing demographic patterns suggest gentrification, therefore, policies that promote equitable development such as inclusionary zones and affordable housing mandates are important to mitigate gentrification. Identifying at risk neighborhoods would enable targeted interventions to protect long-term residents from displacement.</p>
<p><strong>Future Work</strong> Some future work includes expanding the timeline to view shifts in trends and demographics across the city prior to 2010. Furthermore, next steps would involve looking at the other two factors that characterize gentrification; reduced supply of affordable units and new investments in historically marginalized neighborhoods to understand the trends in these factors and develop a more robust conclusion about gentrification patterns in the city. It would also be helpful to look at other demographic patterns such as education level across the city over time.</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>